name: Creare et Publicare Inscriptorem per Rete

on:
  push:
    branches: [ main ]
  workflow_dispatch:
  release:
    types: [published]

permissions:
  contents: write
  pages: write
  id-token: write

jobs:
  creare_et_publicare:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: Code/PocketMage_V3

    steps:
      - name: Checkout release tag
        if: github.event_name == 'release'
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.release.tag_name }}
          fetch-depth: 0

      - name: Checkout main
        if: ${{ github.event_name != 'release' }}
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Prepare the Python Cauldron
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Summon PlatformIO, esptool & jq
        run: |
          set -euo pipefail
          pip install -U platformio esptool
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Forge the PocketMage Firmware
        run: |
          set -euo pipefail
          pio run -e PM_V3
          echo "Build directory contents:"
          ls -lh .pio/build/PM_V3/*.bin

      - name: Divine Partition Offsets
        id: offsets
        run: |
          set -euo pipefail
          
          # Read offsets from partition CSV (expect 0x-prefixed hex or decimal)
          APP0_OFFSET=$(grep "^app0," partitions_4APP.csv | cut -d',' -f4 | tr -d ' ')
          PARTITIONS_OFFSET="0x8000"  # Standard for ESP32
          
          echo "bootloader_offset=0x0" >> $GITHUB_OUTPUT
          echo "partitions_offset=$PARTITIONS_OFFSET" >> $GITHUB_OUTPUT
          echo "app0_offset=$APP0_OFFSET" >> $GITHUB_OUTPUT
          
          echo "Partition offsets:"
          echo "  Bootloader: 0x0"
          echo "  Partitions: $PARTITIONS_OFFSET"
          echo "  App0: $APP0_OFFSET"

      - name: Determine the Flash Sigils (parameters)
        id: flash_params
        run: |
          set -euo pipefail
          
          FLASH_MODE="dio"
          FLASH_FREQ="80m"
          FLASH_SIZE="16MB"
          
          echo "flash_mode=$FLASH_MODE" >> $GITHUB_OUTPUT
          echo "flash_freq=$FLASH_FREQ" >> $GITHUB_OUTPUT
          echo "flash_size=$FLASH_SIZE" >> $GITHUB_OUTPUT
          
          echo "Flash parameters: mode=$FLASH_MODE freq=$FLASH_FREQ size=$FLASH_SIZE"

      - name: Determine Version Tag
        id: version
        run: |
          set -euo pipefail
          
          # Retrieve release tag (empty when not triggered by release event)
          RELEASE_TAG="${{ github.event.release.tag_name }}"
          
          # Use timestamped dev version for non-release builds
          if [ -z "$RELEASE_TAG" ]; then
            RELEASE_TAG="dev-$(date +%Y%m%d-%H%M%S)"
          fi
          
          echo "release_tag=$RELEASE_TAG" >> $GITHUB_OUTPUT
          echo "Determined version: $RELEASE_TAG"

      - name: Scribe the Firmware Manifest
        run: |
          set -euo pipefail

          RELEASE_TAG="${{ steps.version.outputs.release_tag }}"

          BUILD_DIR="$GITHUB_WORKSPACE/Code/PocketMage_V3/.pio/build/PM_V3"
          TARGET_DIR="$GITHUB_WORKSPACE/docs/firmware/${RELEASE_TAG}"
          mkdir -p "${TARGET_DIR}"

          # Copy all firmware files
          cp "${BUILD_DIR}/firmware.bin" "${TARGET_DIR}/firmware.bin"
          cp "${BUILD_DIR}/bootloader.bin" "${TARGET_DIR}/bootloader.bin"
          cp "${BUILD_DIR}/partitions.bin" "${TARGET_DIR}/partitions.bin"

          echo "Firmware files copied to ${TARGET_DIR}"

          # Get partition offsets from previous step
          PARTITIONS_OFFSET="${{ steps.offsets.outputs.partitions_offset }}"
          APP0_OFFSET_HEX="${{ steps.offsets.outputs.app0_offset }}"

          # Convert hex (0x...) or decimal to decimal using bash arithmetic expansion
          to_decimal() {
            local v="$1"
            # strip whitespace
            v=$(echo "$v" | tr -d '[:space:]')
            if [[ "$v" =~ ^0x ]] || [[ "$v" =~ ^0X ]]; then
              # arithmetic expansion handles 0x### format
              echo $((v))
            else
              # if it's already decimal or empty, echo as-is (ensure numeric)
              if [[ -z "$v" ]]; then
                echo 0
              else
                echo $((v))
              fi
            fi
          }

          PARTITIONS_OFFSET_DEC=$(to_decimal "$PARTITIONS_OFFSET")
          APP0_OFFSET_DEC=$(to_decimal "$APP0_OFFSET_HEX")

          echo "Offsets: Partitions=${PARTITIONS_OFFSET} (${PARTITIONS_OFFSET_DEC}), App=${APP0_OFFSET_HEX} (${APP0_OFFSET_DEC})"

          # Create a single manifest with all parts
          jq -n \
            --arg ver "$RELEASE_TAG" \
            --argjson part_off "$PARTITIONS_OFFSET_DEC" \
            --argjson app_off "$APP0_OFFSET_DEC" \
            '{
              name: "PocketMage OS",
              version: $ver,
              home_assistant_domain: "",
              new_install_prompt_erase: true,
              builds: [{
                chipFamily: "ESP32-S3",
                parts: [
                  {
                    path: "bootloader.bin",
                    offset: 0
                  },
                  {
                    path: "partitions.bin",
                    offset: $part_off
                  },
                  {
                    path: "firmware.bin",
                    offset: $app_off
                  }
                ]
              }]
            }' > "${TARGET_DIR}/manifest.json"

          echo "Created manifest file for version: $RELEASE_TAG"

          # Ensure docs folder exists (important)
          mkdir -p "$GITHUB_WORKSPACE/docs"

          # Update or create version index
          INDEX_FILE="$GITHUB_WORKSPACE/docs/manifest-index.json"
          if [ -f "${INDEX_FILE}" ]; then
            # Prepend new version and remove duplicates while preserving first occurrence (so newest is first)
            jq --arg v "$RELEASE_TAG" '
              def uniq_preserve: reduce .[] as $i ([]; if index($i)==null then . + [$i] else . end);
              ([$v] + (.versions // [])) | uniq_preserve | {versions: .}
            ' "${INDEX_FILE}" > "${INDEX_FILE}.tmp"
            mv "${INDEX_FILE}.tmp" "${INDEX_FILE}"
          else
            jq -n --arg v "$RELEASE_TAG" '{versions: [$v]}' > "${INDEX_FILE}"
          fi

          echo "Updated manifest-index.json with version: $RELEASE_TAG"
          echo "manifest-index.json content:"
          cat "$INDEX_FILE"

      - name: Write the Deploy Info Scroll
        run: |
          set -euo pipefail
          mkdir -p "$GITHUB_WORKSPACE/docs"

          RELEASE_TAG="${{ steps.version.outputs.release_tag }}"

          jq -n \
            --arg release_tag "$RELEASE_TAG" \
            --arg run_id "$GITHUB_RUN_ID" \
            --arg run_number "$GITHUB_RUN_NUMBER" \
            --arg sha "$GITHUB_SHA" \
            --arg timestamp "$(date --utc +%Y-%m-%dT%H:%M:%SZ)" \
            '{release_tag: $release_tag, run_id: $run_id, run_number: $run_number, sha: $sha, timestamp: $timestamp}' \
            > "$GITHUB_WORKSPACE/docs/deploy-info.json"

          echo "Wrote deploy-info.json:"
          cat "$GITHUB_WORKSPACE/docs/deploy-info.json"

      - name: Preserve release artifacts from existing gh-pages (merge previous releases, keep last 2 devs)
        run: |
          set -euo pipefail
          # Clone gh-pages branch into a temp location (if it exists) to preserve release artifacts
          TMP_DIR=$(mktemp -d)
          REPO_URL="https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git"
          KEEP_DEV_COUNT=2

          echo "Attempting to clone gh-pages branch to inspect existing published assets..."
          if git clone --depth=1 --branch gh-pages "$REPO_URL" "$TMP_DIR" 2>/dev/null; then
            echo "gh-pages branch cloned to $TMP_DIR"
            # Ensure workspace docs firmware directory exists
            mkdir -p "$GITHUB_WORKSPACE/docs/firmware"

            # Copy existing release (non-dev-) firmware directories into workspace docs/firmware
            if [ -d "$TMP_DIR/docs/firmware" ]; then
              echo "Copying release firmware directories from gh-pages into workspace docs/firmware..."
              # Only copy directories that do NOT start with dev-
              find "$TMP_DIR/docs/firmware" -maxdepth 1 -mindepth 1 -type d ! -name 'dev-*' -print0 | while IFS= read -r -d '' dir; do
                base=$(basename "$dir")
                echo "  copying release dir: $base"
                # preserve existing release directories; overwrite if same name
                rm -rf "$GITHUB_WORKSPACE/docs/firmware/$base" || true
                cp -a "$dir" "$GITHUB_WORKSPACE/docs/firmware/$base"
              done || true

              echo "Identifying the newest $KEEP_DEV_COUNT dev-* versions from gh-pages..."
              # Get all dev dirs from gh-pages, sort them (lexicographically newest last), keep last N
              mapfile -t old_dev_dirs < <(find "$TMP_DIR/docs/firmware" -maxdepth 1 -mindepth 1 -type d -name 'dev-*' -printf '%f\n' | sort)
              old_dev_count=${#old_dev_dirs[@]}
              
              if [ "$old_dev_count" -gt 0 ]; then
                # Calculate how many old devs to keep (last N in sorted order = newest N)
                start_index=0
                if [ "$old_dev_count" -gt "$KEEP_DEV_COUNT" ]; then
                  start_index=$(( old_dev_count - KEEP_DEV_COUNT ))
                fi
                
                echo "Found $old_dev_count existing dev versions, keeping last $KEEP_DEV_COUNT..."
                for i in $(seq "$start_index" $((old_dev_count - 1))); do
                  dev_name="${old_dev_dirs[$i]}"
                  echo "  copying dev dir: $dev_name"
                  rm -rf "$GITHUB_WORKSPACE/docs/firmware/$dev_name" || true
                  cp -a "$TMP_DIR/docs/firmware/$dev_name" "$GITHUB_WORKSPACE/docs/firmware/$dev_name"
                done
              else
                echo "No existing dev versions found in gh-pages"
              fi
            fi

            # Now handle the new version (current build) - if it's a dev version, we need to make room
            CURRENT_VERSION="${{ steps.version.outputs.release_tag }}"
            
            if [[ "$CURRENT_VERSION" == dev-* ]]; then
              echo "Current build is a dev version ($CURRENT_VERSION), will ensure only $KEEP_DEV_COUNT total dev versions exist"
              # After copying old devs, count total dev versions (including the new one about to be added)
              # The new one is already in docs/firmware from the "Scribe the Firmware Manifest" step
            fi

            # Prune dev-* firmware directories in workspace to keep only the newest KEEP_DEV_COUNT
            if [ -d "$GITHUB_WORKSPACE/docs/firmware" ]; then
              echo "Final pruning: keeping only the newest $KEEP_DEV_COUNT dev-* directories..."
              mapfile -t all_dev_dirs < <(find "$GITHUB_WORKSPACE/docs/firmware" -maxdepth 1 -mindepth 1 -type d -name 'dev-*' -printf '%f\n' | sort)
              total_devs=${#all_dev_dirs[@]}
              
              if [ "$total_devs" -gt "$KEEP_DEV_COUNT" ]; then
                to_remove=$(( total_devs - KEEP_DEV_COUNT ))
                echo "Found $total_devs dev versions total; removing $to_remove oldest..."
                for i in $(seq 0 $((to_remove - 1))); do
                  remove_name="${all_dev_dirs[$i]}"
                  echo "  removing old dev dir: $remove_name"
                  rm -rf "$GITHUB_WORKSPACE/docs/firmware/$remove_name" || true
                done
              else
                echo "Dev count ($total_devs) <= $KEEP_DEV_COUNT; nothing to prune."
              fi
            fi

            # Rebuild manifest-index.json from what's actually in docs/firmware after pruning
            echo "Rebuilding manifest-index.json based on actual firmware directories..."
            # Get all release versions (non-dev)
            mapfile -t release_versions < <(find "$GITHUB_WORKSPACE/docs/firmware" -maxdepth 1 -mindepth 1 -type d ! -name 'dev-*' -printf '%f\n' | sort -V -r)
            # Get all dev versions (already sorted and pruned)
            mapfile -t dev_versions < <(find "$GITHUB_WORKSPACE/docs/firmware" -maxdepth 1 -mindepth 1 -type d -name 'dev-*' -printf '%f\n' | sort -r)
            
            # Combine: dev versions first (newest first), then releases (newest first)
            all_versions=("${dev_versions[@]}" "${release_versions[@]}")
            
            # Build JSON array
            version_json=$(printf '%s\n' "${all_versions[@]}" | jq -R . | jq -s .)
            echo "$version_json" | jq '{versions: .}' > "$GITHUB_WORKSPACE/docs/manifest-index.json"
            
            echo "Rebuilt manifest-index.json:"
            cat "$GITHUB_WORKSPACE/docs/manifest-index.json"

            # Copy any other desired static assets from gh-pages that are not transient (optional)
            for f in index.html logo.png favicon.png deploy-info.json; do
              if [ ! -f "$GITHUB_WORKSPACE/docs/$f" ] && [ -f "$TMP_DIR/docs/$f" ]; then
                echo "Preserving existing $f from gh-pages"
                cp -a "$TMP_DIR/docs/$f" "$GITHUB_WORKSPACE/docs/$f"
              fi
            done

          else
            echo "No gh-pages branch present (or clone failed); nothing to preserve."
          fi

      - name: Copy the Web Flasher Shrine (interface)
        run: |
          set -euo pipefail
          mkdir -p "$GITHUB_WORKSPACE/docs"
          cp "$GITHUB_WORKSPACE/Code/WebFlasher/index.html" "$GITHUB_WORKSPACE/docs/index.html"
          cp "$GITHUB_WORKSPACE/Code/WebFlasher/logo.png" "$GITHUB_WORKSPACE/docs/logo.png"
          cp "$GITHUB_WORKSPACE/Code/WebFlasher/favicon.png" "$GITHUB_WORKSPACE/docs/favicon.png"
          echo "Copied web flasher interface"
          echo "docs/ tree to be published:"
          ls -la "$GITHUB_WORKSPACE/docs" || true

      - name: Deploy to gh-pages (peaceiris/actions-gh-pages)
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./docs
          commit_message: "chore(pages): deploy docs from run ${{ github.run_number }}"